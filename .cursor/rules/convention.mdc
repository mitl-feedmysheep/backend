---
description: 
globs: 
alwaysApply: true
---
# IntoTheHeaven Project Development Convention

This document defines the development conventions for the IntoTheHeaven project to maintain a consistent code style and architecture.

## 1. Architecture: Hexagonal Architecture

This project is based on Hexagonal Architecture. The roles and responsibilities of each layer are as follows.

- **`domain`**: Contains the core business logic. It must not have dependencies on any frameworks or external technologies.

  - `model`: Core domain models such as Aggregate Roots, Entities, and Value Objects (VOs).
  - `enums`: Enum types used within the domain.
  - `exception`: Custom business exceptions related to the domain.

- **`application`**: Handles user requests and orchestrates domain services to control the business flow.

  - `port.in`: Ports for requests coming from outside (Adapters) into the Application layer. Typically named as `UseCase` interfaces.
  - `port.out`: Ports for requests going from the Application layer to the outside (Adapters).
  - `service`: Service classes that implement the `UseCase` interfaces. Application-level technologies like `@Transactional` can be used here.

- **`adapter`**: Responsible for interacting with the outside world.

  - `in`: Delivers external requests to the application layer.
    - `web`: Spring MVC controllers (`@RestController`).
  - `out`: Delivers application requests to external systems (DB, API, etc.) and returns the results.
    - `persistence`: DB-related logic such as JPA Entities and Repository implementations.
    - `client`: External API clients.

- **`global`**: Common modules used throughout the project.
  - `config`: Configuration files for Spring, QueryDSL, etc.
  - `util`: Common utility classes.
  - `exception`: Global exception handlers.

### Core Architectural Principles

- **Data Consistency with ERD**: All `domain.model` classes and `adapter.out.persistence.entity` classes must be designed based on the `into-the-heaven.erd.json` file. This ERD serves as the single source of truth for the data model, ensuring consistency between the database schema and the application code. Any changes to the data structure should be reflected in the ERD first.

- **CQS (Command and Query Separation)**: We apply CQS starting from the `application` layer. The `port.in` (UseCases) and `service` packages are separated into `command` and `query` sub-packages. This separation recognizes that commands (state changes) and queries (data retrieval) have different requirements and optimization strategies.

- **Domain Logic Placement**:
  - **Domain Model**: Logic that operates on a single domain aggregate and its internal state (e.g., calculating a member's age from their birthdate) should be placed within the domain model class itself. This follows the Information Expert principle and increases cohesion.
  - **Application Service**: Logic that coordinates between different domain models or aggregates (e.g., calculating the average age of a group) belongs in the `application` service. The service is responsible for orchestrating the flow, fetching necessary data from ports, and calling domain methods.

- **DTO Conversion Principle**: In the query flow, application services (`UseCase`) should return pure domain models. The responsibility for converting these domain models into Data Transfer Objects (DTOs) for the presentation layer lies with the `adapter.in.web.controller`. This ensures that the application core remains independent of specific presentation formats.
  - **Example**: A `UseCase` returns `List<Group>`, and the `Controller` maps it to `List<GroupResponse>`.
  - **Implementation**: The conversion logic should be encapsulated within the DTO class itself using a static `from` method. Method overloading should be used to handle both single objects and lists.
    ```java
    // In SomeResponse.java
    public static SomeResponse from(SomeDomainObject domain) { /* ... */ }
    public static List<SomeResponse> from(List<SomeDomainObject> domains) { /* ... */ }

    // In SomeController.java
    // Single object conversion
    SomeDomainObject domainObject = useCase.findSomething();
    SomeResponse response = SomeResponse.from(domainObject);
    return ResponseEntity.ok(response);

    // List conversion
    List<SomeDomainObject> domainObjects = useCase.findManyThings();
    List<SomeResponse> response = SomeResponse.from(domainObjects);
    return ResponseEntity.ok(response);
    ```

## 2. Package Structure

The package structure is organized based on the hexagonal architecture layers and CQS pattern.

```
src/main/java/mitl/IntoTheHeaven
├── domain
│   ├── model
│   └── enums
├── application
│   ├── port
│   │   ├── in
│   │   │   ├── command
│   │   │   │   └── dto
│   │   │   └── query
│   │   └── out
│   └── service
│       ├── command
│       └── query
├── adapter
│   ├── in
│   │   └── web
│   │       ├── controller
│   │       └── dto
│   └── out
│       └── persistence
│           ├── entity
│           ├── mapper
│           └── repository
└── global
    └── config
```

## 3. Naming Convention

- **UseCase (In-Port)**: `[Domain]QueryUseCase`, `[Domain]CommandUseCase`
  - _Example_: `MemberQueryUseCase`, `MemberCommandUseCase`
- **Service (UseCase Impl)**: `[Domain]QueryService`, `[Domain]CommandService`
  - _Example_: `MemberQueryService`, `MemberCommandService`
- **Port (Out-Port)**: `[Domain]Port`
  - _Example_: `MemberPort`
- **Adapter (Out-Adapter)**: `[Domain]PersistenceAdapter`
  - _Example_: `MemberPersistenceAdapter`
- **Controller**: `[Domain]Controller`
  - _Example_: `MemberController`
- **Request/Response DTO**: `[Action][Domain]Request`, `[Action][Domain]Response`
  - _Example_: `SignUpRequest`, `FindMemberResponse`
- **Command/Query DTO**: `[Action]Command`, `[Data]Query`
  - _Example_: `SignUpCommand`
- **JPA Entity**: `[Domain]JpaEntity`
  - _Example_: `MemberJpaEntity`
- **Mapper**: `[Domain]PersistenceMapper`
  - _Example_: `MemberPersistenceMapper`

## 4. API Design Principles (RESTful)

- **URI**: Resources should be represented by nouns (plural). (`/members`, `/groups/{groupId}/gatherings`)
- **HTTP Method**: Actions on resources are expressed by HTTP Methods.
  - `POST`: Create a resource.
  - `GET`: Retrieve a resource.
  - `PUT` / `PATCH`: Update a resource (full/partial).
  - `DELETE`: Delete a resource.
- **Response Format**: Use JSON as the default, with `camelCase` for keys.
- **Success Responses**: `200 OK`, `201 Created`, `204 No Content`
- **Error Responses**: `400 Bad Request`, `401 Unauthorized`, `403 Forbidden`, `404 Not Found`, `500 Internal Server Error`

## 5. Commit Message Convention

Follow the [Conventional Commits](mdc:https:/www.conventionalcommits.org/en/v1.0.0) specification.

- **Format**: `type(scope): subject`
- **`type`**:
  - `feat`: A new feature
  - `fix`: A bug fix
  - `docs`: Documentation only changes
  - `refactor`: A code change that neither fixes a bug nor adds a feature
  - `test`: Adding missing tests or correcting existing tests
- **Example**:
  - `feat(member): add user signup API`
  - `refactor(group): refactor Group domain model`

## 6. Code Style

- **Lombok**: Actively use annotations like `@Getter`, `@Builder`, `@RequiredArgsConstructor` to minimize boilerplate code.
- **Immutability**: Design DTOs and Value Objects to be immutable where possible.
- **Validation**: Perform primary validation at the Controller DTO level using `@Valid`.
- **Exception Handling**: Define business exceptions in the `domain` or `application` layer and handle them globally using `@RestControllerAdvice`.

## 7. Key Implementation Patterns and Conventions

This section covers specific patterns and conventions adopted in the project to address common challenges.

### a. Data Fetching and N+1 Problem

To prevent the N+1 query problem, we use JPA's EntityGraph feature for eager fetching of related entities in a single query (Fetch Join).

-   **Primary Method**: Use `@EntityGraph` directly on repository methods. While powerful, be aware of its limitations.
    -   **Example**: In `MemberJpaRepository`, `findWithGroupsById` uses `@EntityGraph` to fetch `groupMembers` and their associated `group` in one go.
      ```java
      // In MemberJpaRepository.java
      @EntityGraph(attributePaths = {"groupMembers", "groupMembers.group"})
      Optional<MemberJpaEntity> findWithGroupsById(UUID memberId);
      ```
-   **Convention**:
    -   For simple, one-off fetch joins, using `@EntityGraph` is acceptable for its simplicity.
    -   For complex, dynamic, or frequently reused queries, consider using QueryDSL to ensure type safety and maintainability. The project is already configured for QueryDSL.
    -   Raw JPQL queries (`@Query`) should be avoided in favor of JPA's method name conventions or QueryDSL. This enhances type safety and reduces the risk of runtime errors from typos in query strings.

### b. Adapter Responsibilities and Repository Usage

An adapter's purpose is to implement a port and bridge the application layer to an external technology (like a database).

-   **Principle**: An adapter is not restricted to using only the repository that matches its name. It should use whatever repositories are necessary to fulfill its port's contract in the most efficient way.
-   **Example**: `GroupPersistenceAdapter` implements `GroupPort`. To fulfill the `findGroupsByMemberId` method, it uses `MemberJpaRepository`. This is the correct approach because the query starts with a `memberId`, making `Member` the logical starting point for the database query, based on the ERD.
-   **Guideline**: The choice of which repository to use within an adapter should be driven by the data model (ERD) and query efficiency, not by the adapter's name.

### c. JPA Entity Design Conventions

To ensure consistency, maintainability, and alignment with our architecture, all JPA Entity classes must adhere to the following design conventions:

-   **Base Entity Inheritance**: All entities must extend a common `BaseEntity` class. This centralizes common fields like `id`, `createdAt`, `updatedAt`, and `deletedAt`, reducing code duplication and ensuring a consistent structure across all tables.

-   **Builder Pattern for Instantiation**: Entities should be instantiated using the Builder pattern. For entities in an inheritance hierarchy (i.e., all entities extending `BaseEntity`), a mechanism that supports parent class fields (like Lombok's `@SuperBuilder`) must be used. This provides a readable and fluent API for object creation.
    -   **Encapsulation**: To enforce the use of the builder, direct instantiation via constructors must be prevented. The no-argument constructor should be `protected` for JPA's internal use, and the all-arguments constructor should be `private`, making it accessible only to the builder.

-   **Global Soft-Delete Filter**: To ensure that queries only return active records, a global filter (like Hibernate's `@SQLRestriction`) should be applied at the entity level to automatically exclude records where `deleted_at` is not null. This simplifies application logic, as individual queries do not need to concern themselves with filtering for soft-deleted records.

-   **Standard-Compliant Field Documentation**: Field descriptions should be documented using standard JavaDoc comments (`/** ... */`) rather than implementation-specific annotation properties (like `comment` in Hibernate's `@Column`). This improves code portability and ensures that documentation is independent of the underlying persistence provider.

-   **ERD-Driven Relationships**: All entity relationships (`@ManyToOne`, `@OneToMany`, etc.) and column attributes (`nullable`, `length`, etc.) must accurately reflect the definitions in the project's ERD (`into-the-heaven.erd.json`). The ERD is the single source of truth for the data model.
